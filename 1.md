# ğŸš€ Flask CI/CD with Terraform, Ansible, Docker, Prometheus & Grafana

This project is a fully automated infrastructure and deployment pipeline for a **Flask-based web application** hosted on AWS. It uses **Terraform** for infrastructure provisioning, **Ansible** for configuration and deployment, and **Docker** for containerizing the application and monitoring tools like **Prometheus**, **Node Exporter**, and **Grafana**.

The goal is to showcase a complete DevOps workflow using open-source tools, with modular code and infrastructure-as-code best practices.

## ğŸ› ï¸ Tech Stack

- **Flask** â€“ Lightweight Python web framework for building the application.
- **Docker** â€“ Containerizes the application and monitoring tools.
- **Docker Compose** â€“ Manages multi-container setup (Flask, Prometheus, Grafana, Node Exporter).
- **Terraform** â€“ Provisions AWS infrastructure as code (EC2, VPC, Subnets, ALB, Security Groups, etc.).
- **Ansible** â€“ Handles server provisioning, app deployment, and monitoring stack automation.
- **Prometheus** â€“ Time-series database and monitoring system.
- **Node Exporter** â€“ Collects host-level system metrics.
- **Grafana** â€“ Visualizes metrics and builds monitoring dashboards.
- **AWS** â€“ Cloud provider hosting the entire infrastructure.
- **GitHub** â€“ Source code repository and version control.

## ğŸ“ Project Structure

Flask-CI-CD/ â”‚ â”œâ”€â”€ ansible/ # Ansible automation â”‚ â”œâ”€â”€ inventory.ini # Inventory file for Ansible (target host) â”‚ â”œâ”€â”€ playbook.yml # Main playbook to set up app and monitoring â”‚ â””â”€â”€ monitoring/ # Monitoring configuration â”‚ â”œâ”€â”€ docker-compose.yml # Docker Compose config for Prometheus, Grafana, Node Exporter â”‚ â””â”€â”€ prometheus.yml # Prometheus scrape configuration â”‚ â”œâ”€â”€ terraform/ # Terraform code for infrastructure â”‚ â”œâ”€â”€ main.tf # AWS resources definition (VPC, EC2, ALB, etc.) â”‚ â”œâ”€â”€ variables.tf # Input variables â”‚ â”œâ”€â”€ outputs.tf # Outputs like public IP, ALB DNS â”‚ â””â”€â”€ terraform.tfvars # Actual values of the input variables â”‚ â”œâ”€â”€ app/ # Flask application (source code) â”‚ â”œâ”€â”€ Dockerfile # Dockerfile for Flask app â”‚ â”œâ”€â”€ app.py # Flask application code â”‚ â””â”€â”€ requirements.txt # Python dependencies â”‚ â”œâ”€â”€ .gitignore # Files and folders ignored by Git â”œâ”€â”€ README.md # Project documentation â””â”€â”€ LICENSE # Project license

## âœ¨ Features

- ğŸš€ **Fully Automated Infrastructure Setup**  
  Uses Terraform to provision an entire AWS environment including:
  - VPC with public subnets
  - Internet Gateway and Route Tables
  - Security Groups for EC2 and ALB
  - EC2 instance running Dockerized Flask app
  - Application Load Balancer for public access

- âš™ï¸ **End-to-End CI/CD with Ansible**  
  Ansible automates:
  - Flask app deployment
  - Docker & Docker Compose setup
  - Monitoring stack setup (Prometheus + Grafana + Node Exporter)

- ğŸ“ˆ **Integrated Monitoring**  
  - Prometheus to scrape metrics
  - Grafana dashboards for real-time visualization
  - Node Exporter for system-level metrics on EC2

- ğŸ“¦ **Dockerized Flask Application**  
  - Lightweight and portable
  - Can be replaced or scaled with minimal configuration

- ğŸŒ **Highly Configurable & Modular**  
  - Infrastructure as Code (IaC)
  - Easy to update, scale, or adapt across different environments

- ğŸ› ï¸ **Clean & Reusable Codebase**  
  - Well-structured and production-ready
  - Clear separation of concerns between Terraform, Ansible, and App layers

## âœ… Prerequisites

Before running this project, ensure you have the following installed and configured on your local machine:

### ğŸ”§ Tools Required

- **Terraform** (v1.0+ recommended)  
  Infrastructure provisioning

- **Ansible** (v2.9+ recommended)  
  Configuration management & automation

- **AWS CLI** (configured with credentials)  
  For Terraform & Ansible to interact with AWS

- **SSH Key Pair**  
  Required to access EC2 instance  
  âš ï¸ **Do not upload your `.pem` key to any public repository**

- **Docker** & **Docker Compose**  
  For local testing and service orchestration (optional)

### ğŸ” AWS Resources Required

- An AWS account with:
  - EC2, VPC, IAM, and ALB access
  - A valid key pair created in the EC2 section

### ğŸ“¦ Python Packages (if running Ansible from virtualenv)

```bash
pip install boto boto3

Ensure your SSH key (.pem file) path and other variables are correctly configured inside the inventory.ini and ansible.cfg files.

## ğŸš€ How to Use

Follow these steps to provision infrastructure, deploy the app, and enable monitoring:

### 1ï¸âƒ£ Clone the Repository

```bash
git clone https://github.com/OmkarSG07/Flask-CI-CD.git
cd Flask-CI-CD

cd terraform
terraform init
terraform apply
```
âœ… This will set up the entire AWS infrastructure: VPC, Subnets, Internet Gateway, EC2 instance, and ALB.

After Terraform finishes, get the public IP of the EC2 instance from the output and update the inventory file:
# ansible/inventory.ini
[flask_server]
your-ec2-public-ip ansible_user=ubuntu ansible_ssh_private_key_file=/path/to/your/key.pem

cd ../ansible
ansible-playbook -i inventory.ini playbook.yml
âœ… This installs Docker, runs the Flask app, and sets up Prometheus + Grafana on the EC2 instance.

5ï¸âƒ£ Access the Services

    Flask App: http://<EC2-Public-IP>:5000

    Grafana Dashboard: http://<EC2-Public-IP>:3000

        Default Login: admin / admin

    Prometheus: http://<EC2-Public-IP>:9090

    Node Exporter Metrics: http://<EC2-Public-IP>:9100/metrics

    ## ğŸ“Š Monitoring Overview

This project integrates Prometheus and Grafana to monitor your Flask application running in Docker. Here's how the monitoring system is set up and how you can use it:

### 1ï¸âƒ£ Prometheus Configuration

Prometheus is configured to scrape metrics from:

- **Node Exporter**: Provides hardware and OS metrics from the EC2 instance.
- **Flask App**: You can extend Prometheus to scrape Flask app-specific metrics by exposing an endpoint in your Flask application.

Prometheus config (`prometheus.yml`) is located in the `ansible/monitoring` directory and is set up to scrape both `Node Exporter` and `Flask App`.

---

### 2ï¸âƒ£ Grafana Dashboard

Once the infrastructure is set up and the containers are running, you can access the Grafana dashboard at:

- **Grafana URL**: `http://<EC2-Public-IP>:3000`

#### Default Login:
- **Username**: `admin`
- **Password**: `admin`

Upon logging in, you can import and view pre-configured dashboards to monitor:

- EC2 metrics (CPU, memory, disk usage, etc.)
- Flask application performance (e.g., request rate, response time)

> ğŸ”§ You can also create custom dashboards and panels as per your monitoring needs.

---

### 3ï¸âƒ£ Node Exporter

Node Exporter runs on the EC2 instance and exposes various system metrics (CPU, memory, disk, network usage). It is available on port `9100`:

- **Node Exporter URL**: `http://<EC2-Public-IP>:9100/metrics`

---

### 4ï¸âƒ£ Alerts (Optional)

You can configure alerting in Prometheus or Grafana to notify you on various conditions like:

- High CPU usage
- Flask app down
- Low disk space

This requires setting up notification channels like email, Slack, or others, depending on your preference.

## ğŸ› ï¸ Troubleshooting

While working with Flask, Docker, Ansible, and Terraform, issues might arise. Here are some common problems and their solutions:

### 1ï¸âƒ£ **EC2 Instance Not Starting**

- **Cause**: The EC2 instance might not have started successfully.
- **Solution**: 
  - Check EC2 instance status in the AWS console.
  - Ensure that the `ami_id` in your Terraform configuration is correct.
  - Review the instance's **System Logs** in the AWS console for error messages.

### 2ï¸âƒ£ **Docker Containers Not Running**

- **Cause**: Docker containers might not be starting as expected.
- **Solution**: 
  - Check the container logs:
    ```bash
    docker logs <container-name>
    ```
  - Ensure Docker service is running:
    ```bash
    systemctl status docker
    ```
  - Inspect the running containers:
    ```bash
    docker ps
    ```
  
### 3ï¸âƒ£ **Flask App Not Accessible**

- **Cause**: Flask app may not be accessible from the browser.
- **Solution**:
  - Verify if the Flask app container is running and the port is exposed properly (`5000:5000`).
  - Ensure the **Security Group** rules for the EC2 instance are configured correctly to allow access to port `5000`.
  - Check the **Docker logs** for the Flask app container:
    ```bash
    docker logs flask-app-container
    ```

### 4ï¸âƒ£ **Prometheus/Grafana Not Displaying Data**

- **Cause**: Prometheus and Grafana may not be receiving data.
- **Solution**:
  - Ensure Prometheus is scraping both **Node Exporter** and the **Flask App**.
  - Check the Prometheus logs for any scraping errors.
  - Ensure the correct targets are listed in Prometheus' **`prometheus.yml`** file.
  - In Grafana, ensure the data source is correctly configured to point to the Prometheus instance.

### 5ï¸âƒ£ **Terraform Apply Fails**

- **Cause**: Terraform might fail to apply changes due to misconfigurations.
- **Solution**:
  - Check the error messages printed by Terraform.
  - Ensure that AWS credentials are correctly configured for Terraform.
  - Run `terraform plan` to inspect the planned changes and validate before applying.
  - For any IAM-related issues, ensure the IAM user has the correct permissions for creating resources.

### 6ï¸âƒ£ **Ansible Playbook Fails**

- **Cause**: The Ansible playbook might fail due to incorrect configurations or missing dependencies.
- **Solution**:
  - Check the output logs for the error messages.
  - Ensure the EC2 instance is reachable and that SSH keys are correctly configured.
  - Verify that the necessary roles and variables are defined in the `ansible/` directory.
  - Run the playbook with increased verbosity for more detailed logs:
    ```bash
    ansible-playbook -v playbook.yml
    ```
  
### 7ï¸âƒ£ **Security Group Issues**

- **Cause**: EC2 instances or services might not be accessible due to misconfigured security groups.
- **Solution**:
  - Verify the security group rules in the AWS Console.
  - Ensure that ports like `5000` (Flask app) and `3000` (Grafana) are open to the right CIDR blocks.
  - Check for overlapping security group configurations that may cause conflicts.

## ğŸš€ Future Enhancements

As the project grows, there are several areas where we can improve and add additional features to enhance the scalability, performance, and maintainability of the system.

### 1ï¸âƒ£ **Automated Testing and CI/CD**

- **Enhancement**: Integrate automated tests for Flask app endpoints and Docker container functionality.
- **Benefit**: Ensure that the Flask app remains reliable as features and functionality evolve.
- **Tools**: 
  - **pytest** for unit testing Flask routes.
  - **GitHub Actions** for setting up continuous integration and deployment pipelines.

### 2ï¸âƒ£ **Multi-Region Deployment**

- **Enhancement**: Extend the infrastructure setup to support multi-region deployment on AWS.
- **Benefit**: Improve availability and performance by deploying to multiple AWS regions.
- **Steps**:
  - Modify the Terraform configuration to deploy resources across multiple regions.
  - Use AWS Route 53 for traffic routing between regions.

### 3ï¸âƒ£ **Container Orchestration with Kubernetes**

- **Enhancement**: Migrate the Flask app and monitoring stack to a **Kubernetes** setup.
- **Benefit**: Enable easier scaling, management, and orchestration of Docker containers.
- **Tools**: 
  - **Kubernetes** for container orchestration.
  - **Helm** for managing Kubernetes charts and deployments.
  - **AWS EKS** for a managed Kubernetes service.

### 4ï¸âƒ£ **Logging and Monitoring Enhancements**

- **Enhancement**: Expand logging capabilities to capture detailed application logs and errors.
- **Benefit**: Improve debugging and performance monitoring.
- **Tools**:
  - **ELK Stack** (Elasticsearch, Logstash, Kibana) for centralized logging.
  - **Prometheus** and **Grafana** for enhanced metrics and monitoring.

### 5ï¸âƒ£ **Application Auto-Scaling**

- **Enhancement**: Implement auto-scaling for the Flask app EC2 instances based on traffic.
- **Benefit**: Handle traffic spikes more effectively by automatically scaling resources.
- **Tools**:
  - **AWS Auto Scaling** to scale EC2 instances.
  - **AWS CloudWatch** for monitoring resource usage and triggering auto-scaling actions.

### 6ï¸âƒ£ **Database Integration**

- **Enhancement**: Integrate a database such as **PostgreSQL** or **MySQL** with the Flask application.
- **Benefit**: Provide persistent storage for user data and application state.
- **Steps**:
  - Add a database service to the **Docker Compose** setup.
  - Integrate the Flask app to communicate with the database using an ORM like **SQLAlchemy**.

### 7ï¸âƒ£ **Security Improvements**

- **Enhancement**: Improve security by implementing **SSL/TLS encryption** and securing API endpoints.
- **Benefit**: Secure sensitive data and communications between clients and the server.
- **Steps**:
  - Implement **SSL certificates** for HTTPS in Flask.
  - Set up API authentication using **JWT** tokens or **OAuth**.
  
### 8ï¸âƒ£ **Cost Optimization**

- **Enhancement**: Optimize cloud infrastructure to reduce unnecessary costs.
- **Benefit**: Reduce operational costs and improve resource efficiency.
- **Tools**:
  - **AWS Cost Explorer** to monitor and analyze costs.
  - **AWS Trusted Advisor** for cost optimization recommendations.

### 9ï¸âƒ£ **Container Image Optimization**

- **Enhancement**: Optimize the Docker images for smaller sizes and faster deployment.
- **Benefit**: Reduce the container image size and improve deployment times.
- **Tools**:
  - Use **multi-stage builds** in Docker to reduce the final image size.
  - Minimize the number of layers in Docker images.
